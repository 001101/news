// Generated by CoffeeScript 1.6.3
/*

ownCloud - News

@author Bernhard Posselt
@copyright 2012 Bernhard Posselt dev@bernhard-posselt.com

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE
License as published by the Free Software Foundation; either
version 3 of the License, or any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU AFFERO GENERAL PUBLIC LICENSE for more details.

You should have received a copy of the GNU Affero General Public
License along with this library.  If not, see <http://www.gnu.org/licenses/>.
*/


(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  angular.module('News').factory('FeedModel', [
    '_Model', '_EqualQuery', 'Utils', function(_Model, _EqualQuery, Utils) {
      var FeedModel;
      FeedModel = (function(_super) {
        __extends(FeedModel, _super);

        function FeedModel(_utils) {
          this._utils = _utils;
          this._url = {};
          FeedModel.__super__.constructor.call(this);
        }

        FeedModel.prototype.clear = function() {
          this._url = {};
          return FeedModel.__super__.clear.call(this);
        };

        FeedModel.prototype.add = function(data, clearCache) {
          var item, updateById, updateByUrl;
          if (clearCache == null) {
            clearCache = true;
          }
          if (data.faviconLink === null) {
            data.faviconLink = 'url(' + this._utils.imagePath('news', 'rss.svg') + ')';
          } else if (angular.isDefined(data.faviconLink) && data.faviconLink.indexOf('url(') !== 0) {
            data.faviconLink = 'url(' + data.faviconLink + ')';
          }
          /*
          			We want to add a feed on the client side before
          			we have an id from the server. Once the server returns
          			an id, we have to update the existing item without id
          */

          item = this._url[data.url];
          updateById = angular.isDefined(data.id) && angular.isDefined(this.getById(data.id));
          updateByUrl = angular.isDefined(item) && angular.isUndefined(item.id);
          if (updateById || updateByUrl) {
            return this.update(data, clearCache);
          } else {
            if (angular.isDefined(data.url)) {
              this._url[data.url] = data;
              if (angular.isDefined(data.id)) {
                return FeedModel.__super__.add.call(this, data, clearCache);
              } else {
                this._data.push(data);
                if (clearCache) {
                  return this._invalidateCache();
                }
              }
            }
          }
        };

        FeedModel.prototype.update = function(data, clearCache) {
          var item, itemWithId;
          if (clearCache == null) {
            clearCache = true;
          }
          if (angular.isDefined(data.url)) {
            item = this._url[data.url];
          }
          if (angular.isUndefined(data.id) && angular.isDefined(item)) {
            return angular.extend(item, data);
          } else {
            if (angular.isDefined(data.id) && angular.isDefined(item) && angular.isUndefined(item.id)) {
              item.id = data.id;
              this._dataMap[data.id] = item;
            }
            itemWithId = this.getById(data.id);
            if (angular.isDefined(itemWithId) && itemWithId.url !== data.url) {
              delete this._url[itemWithId.url];
              this._url[data.url] = itemWithId;
            }
            return FeedModel.__super__.update.call(this, data, clearCache);
          }
        };

        FeedModel.prototype.removeById = function(id) {
          var item;
          item = this.getById(id);
          delete this._url[item.url];
          return FeedModel.__super__.removeById.call(this, id);
        };

        FeedModel.prototype.getByUrl = function(url) {
          return this._url[url];
        };

        FeedModel.prototype.getUnreadCount = function() {
          var count, feed, _i, _len, _ref;
          count = 0;
          _ref = this.getAll();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            feed = _ref[_i];
            count += feed.unreadCount;
          }
          return count;
        };

        FeedModel.prototype.getFeedUnreadCount = function(feedId) {
          var count, feed;
          feed = this.getById(feedId);
          count = 0;
          if (angular.isDefined(feed)) {
            return count += feed.unreadCount;
          } else {
            return 0;
          }
        };

        FeedModel.prototype.getFolderUnreadCount = function(folderId) {
          var count, feed, query, _i, _len, _ref;
          query = new _EqualQuery('folderId', parseInt(folderId));
          count = 0;
          _ref = this.get(query);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            feed = _ref[_i];
            count += feed.unreadCount;
          }
          return count;
        };

        FeedModel.prototype.getAllOfFolder = function(folderId) {
          var query;
          query = new _EqualQuery('folderId', parseInt(folderId));
          return this.get(query);
        };

        FeedModel.prototype.removeByUrl = function(url, clearCache) {
          var counter, entry, key, value, _i, _len, _ref, _ref1, _results;
          if (clearCache == null) {
            clearCache = true;
          }
          /*
          			Remove an entry by id
          */

          _ref = this._dataMap;
          for (key in _ref) {
            value = _ref[key];
            if (this._dataMap[key].url === url) {
              delete this._dataMap[key];
              break;
            }
          }
          _ref1 = this._data;
          _results = [];
          for (counter = _i = 0, _len = _ref1.length; _i < _len; counter = ++_i) {
            entry = _ref1[counter];
            if (entry.url === url) {
              this._data.splice(counter, 1);
              delete this._url[url];
              if (clearCache) {
                this._invalidateCache();
              }
              break;
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        };

        return FeedModel;

      })(_Model);
      return new FeedModel(Utils);
    }
  ]);

}).call(this);
